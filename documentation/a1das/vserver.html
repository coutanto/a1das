<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>a1das.vserver API documentation</title>
<meta name="description" content="Functions to emulate a DAS interrogator socket server. The DAS is replaced by a file
These functions allows to play file data, or any process applied â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>a1das.vserver</code></h1>
</header>
<section id="section-intro">
<p>Functions to emulate a DAS interrogator socket server. The DAS is replaced by a file
These functions allows to play file data, or any process applied on data, and view them like a movie</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from a1das._a1das_exception import VirtualServerError
import array
import numpy as np
import struct

__doc__=&#34;Functions to emulate a DAS interrogator socket server. The DAS is replaced by a file&#34;+ \
        &#34;\n These functions allows to play file data, or any process applied on data, and view them like a movie&#34;

def ZMQVirtualDasServer(file, host=&#39;127.0.0.1&#39;, port=6667, block=None):
    &#34;&#34;&#34;
    ## Description
    Read Febus strain[rate] HDF5 file and send to a ZMQ socket stream

    ## Input
        file = hdf5 (.h5) file to read
        host = IP adress for the virtual server
        port = IP port for the virtual server

    ## Usage example
        &gt;&gt;&gt; from a1das import vserver
        &gt;&gt;&gt; vserver.ZMQVirtualDasServer(&#39;my_SR_file&#39;,host=&#39;127.0.0.1&#39;,port=6667)
    &#34;&#34;&#34;
    import a1das
    import zmq
    import pickle
    from io import BytesIO
    from timeit import default_timer as timer

    # open ZMQ connection
    context = zmq.Context()
    socket = context.socket(zmq.REP)
    socket.bind(&#34;tcp://%s:%d&#34; % (host, port))
    print(&#39;launching DAS virtual server on address: &lt;&#39;,&#34;tcp://%s:%d&#34; % (host, port),&#39;&gt;&#39;)

    #
    # open file
    #
    f = a1das.open(file)
    # set origin time
    #f.set_otime_from_filename()
    #read block info
    nblock = f.file_header.block_info[&#39;nb_block&#39;]
    #read freq_res
    freq_res = f.file_header.freq_res
    delta_t = 1./freq_res
    #time = f.data_header[&#39;otime&#39;]
    block_times = f.file_header.block_info[&#39;block_times&#39;]
    time = block_times[0]


    # wait for an acq
    _wait_for_acq(socket, time)

    # Set and Send header(s)
    message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket)

    data = a1das._core_febus_file._read_febus_file_block(f, 0)
    time0 = timer()
    socket.send(data)

    if block is None:
        block = [0, nblock]

    for i in range(block[0], block[-1]):
        #
        # wait for acq
        #
        _wait_for_acq(socket, time)

        #
        # resend headers and data
        #
        time1 = timer()
        #temporisation
        #while (time1 - time0 &lt; delta_t):
        #    time1 = timer()
        time0 = time1
        #time += delta_t
        time = block_times[i]
        message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket, message2=message2)

        data = a1das._core_febus_file._read_febus_file_block(f, block=i)
        socket.send(data)


    socket.close()
    f.close()


#
# ========================================= ZMQRAWVIRTUALDASSERVER()  ============================
#
def ZMQRawVirtualDasServer(filein,  GL, DT, order_time=2, order_space=2, trange=None, drange=None, tdecim=1, ddecim=1,
                verbose=0, host=&#39;127.0.0.1&#39;, port=6667):
    &#34;&#34;&#34;
    ## Description
    Convert Febus RAW data HDF5 file to strain[rate] and send them to a ZMQ socket stream

    ## input:
        filein: hdf5 (.h5) file to read
        GL: Gauge length (in meter)
        DT: Derivation time (IN SECOND)
        order_time:  finite derivation order in time, no derivation if set to 0 (default 2)
        order_space: finite derivation order in space (default 2)
        trange:  time range in sec (start,end), (default = None, everything is read)
        drange:  distance range in meter (not km) (start,end), (default = None, everything is read)
        ddecim:  distance decimation factor (default=1)
        tdecim:  time decimation factor (default=1)
        verbose: be verbose (default=0, minimum message level)


    ## Usage example
        &gt;&gt;&gt; from a1das import vserver
        &gt;&gt;&gt; gauge_length=10.
        &gt;&gt;&gt; time_derivation=0.005
        &gt;&gt;&gt; vserver.ZMQRawVirtualDasServer(&#39;my_RAW_file&#39;,gauge_length, time_derivation, host=&#39;127.0.0.1&#39;,port=6667)
    &#34;&#34;&#34;

    import h5py
    from .core import open
    from a1das import _raw2strPy
    from ._a1das_exception import WrongValueError
    from timeit import default_timer as timer
    import zmq

    kchunk = 1
    skip = False
    host = &#39;127.0.0.1&#39;
    port = 6667
    use_compression = False
    #
    #  --------------------------- open file for reading
    #
    a1 = open(filein, format=&#39;febus&#39;)

    # open ZMQ connection
    context = zmq.Context()
    socket = context.socket(zmq.REP)
    socket.bind(&#34;tcp://%s:%d&#34; % (host, port))

    #
    #  --------------------------- read header ----------------------
    #
    hd = a1.file_header
    dhd = a1.data_header
    if hd.chan_node == None:
        print(&#39;Cannot read raw file&#39;)
        exit(-1)
    #
    #  --------------------------- block time size

    block_time_size = int(hd.block_info[&#39;block_time_size&#39;] / 2)

    #
    # check whether time decimation factor is ok or not, it must divide
    # the chunk size
    #
    if (block_time_size) % tdecim != 0:
        print(&#39;Error: time decimation factor must be a divider of the chunk size =&#39;, block_time_size)
        print(&#39;try :&#39;)
        for i in range(2, 100):
            if (block_time_size) % i == 0:
                print(&#39;  tdecim=&#39;, i)
        exit(0)

    #
    #   --------------------------- compute time bounds and time vector -----------------
    #

    # indices for chunk (block) of data
    # indices for first and last time record in the first and last block
    # Vector of times in range[from_time, to_time] with tdecim
    # (block, trange, skip, align_on_block, tdecim)
    first_block, last_block, step_block, \
    time_out, block_indices = a1._get_time_bounds(trange=trange, skip=skip)

    #
    #     ---------------------------  compute distance bounds and indices ----------------
    #
    dist_out, dist_ix, dist_in = a1._get_space_bounds(drange, ddecim)
    if drange is not None:
        ospace_drange = drange[0]
    else:
        ospace_drange = 0.

    #
    # --------------------------- size of data to be written ---------------------------
    #
    output_time_size = len(time_out)  # number of time samples with decimation tdecim
    output_space_size = len(dist_out)  # number of space samples with decimation ddecim
    input_space_size = len(dist_in)  # number of space samples without decimation
    # input_time_size = block_time_size

    #
    #   --------------------------- write header dataset structure on output file
    #   Create a single dataset for all records, stored with a chunk size
    #   approximately equal to : kchunk * original_chunk_size
    #
    # Each block contains decim_block_time_size time samples
    # we will write decim_block_time_size * tdecim * kchunk time sample per chunk
    # A chunk is filled when ncblocks are read
    decim_blk_time_size = int(block_time_size / tdecim)
    decim_blk_space_size = output_space_size
    time_chunk_size = (decim_blk_time_size * tdecim * kchunk)
    if time_chunk_size &gt; output_time_size:
        time_chunk_size = output_time_size
        kchunk = int(time_chunk_size / block_time_size) + 1

    ncblock = kchunk * tdecim


    #
    # create messages from header values
    #
    freq_res = a1.file_header.freq_res
    delta_t = 1./freq_res
    time = dhd[&#39;otime&#39;]

    #
    # test GL and DT parameters
    #
    if GL &lt; dhd[&#39;sampling_res&#39;] / 100:
        raise WrongValueError(
            &#39;Gauge length is smaller than sampling resolutionv&#39; + str(GL) + &#39;&lt;&#39; + str(dhd[&#39;sampling_res&#39;]))
    if DT &lt; (1. / dhd[&#39;prf&#39;]):
        raise WrongValueError(&#39;time derivation is smaller than 1/Pulse_Rate_Frequency&#39;)

    #
    # --------------------------- loop reading blocks ----------------------
    #

    buff_out = np.empty((time_chunk_size, output_space_size, 4), np.int8, &#39;C&#39;)
    strain = np.empty((time_chunk_size, output_space_size), np.float64, &#39;C&#39;)
    print(&#39;size of data is &#39;+str(time_chunk_size)+&#39; x &#39;+str(output_space_size) )

    time0 = timer()
    from timeit import default_timer as timer
    last_block_read = list(range(first_block, last_block, step_block))[-1]
    message2 = None
    for i, block in enumerate(range(first_block, last_block, step_block)):

        # set block indices to read
        if block == first_block:
            block_start = block_indices[0][0]
            block_end = block_indices[0][1]
        elif block == last_block_read:
            block_start = block_indices[2][0]
            block_end = block_indices[2][1]
        else:
            block_start = block_indices[1][0]
            block_end = block_indices[1][1]

        # Fill output buffer; when it&#39;s full, write datasets
        jchunk = i % ncblock

        #
        # Read the full bock and compute angle from real and imaginary part
        # phase 1
        phase1_r = hd.chan_node[0][block, block_start:block_end, :]
        phase1_i = hd.chan_node[1][block, block_start:block_end, :]
        # copy decimated spatial data into temporary buffer
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 0] = \
            phase1_r[:, dist_ix.start:dist_ix.stop:dist_ix.step]
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 1] = \
            phase1_i[:, dist_ix.start:dist_ix.stop:dist_ix.step]

        # Phase2, same as above
        phase2_r = hd.chan_node[2][block, block_start:block_end, :]
        phase2_i = hd.chan_node[3][block, block_start:block_end, :]
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 2] = \
            phase2_r[:, dist_ix.start:dist_ix.stop:dist_ix.step]
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 3] = \
            phase2_i[:, dist_ix.start:dist_ix.stop:dist_ix.step]


        #
        # We have filled the temporary buffer
        # extract time decimated part and convert to strain
        #
        if jchunk == ncblock - 1:

            phase1_r = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 0]).astype(&#39;int32&#39;)
            phase1_i = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 1]).astype(&#39;int32&#39;)
            phase2_r = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 2]).astype(&#39;int32&#39;)
            phase2_i = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 3]).astype(&#39;int32&#39;)
            strain, GL, DT = _raw2strPy.raw2strpy(strain, phase1_r, phase1_i, phase2_r, phase2_i, dist_out, time_out,
                                                 GL, DT, order_space, order_time, verbose)
            data = strain.astype(&#39;float32&#39;)
            time1 = timer()
            while (time1 - time0 &lt; delta_t):
                time1 = timer()
            time0 = time1

            _wait_for_acq(socket,time)
            message2 = _set_and_send_header_to_ZMQ(dhd, hd, time, socket, message2=message2)
            socket.send(data)
            time += delta_t



    # end of file reached, write partially filled buffer
    if jchunk != ncblock - 1:
        phase1_r = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 0])
        phase1_i = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 1])
        phase2_r = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 2])
        phase2_i = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 3])
        strain, GL, DT = _raw2strPy.raw2strpy(strain, phase1_r, phase1_i, phase2_r, phase2_i, dist_out, time_out,
                                             GL, DT, order_space, order_time, verbose)
        data = strain.astype(&#39;float32&#39;)
        # write to socket
        _wait_for_acq(socket,time)
        message2 = _set_and_send_header_to_ZMQ(dhd, hd, time, socket, message2=message2)
        socket.send(data)

    a1.close()
    socket.close()

#
# ========================================= ZMQREDUCTEDVIRTUALDASSERVER()  ============================
#
def ZMQReductedVirtualServer(filein, prefix, trange=None, drange=None, tdecim=1, ddecim=1,
                verbose=0, host=&#39;127.0.0.1&#39;, port=6667, block_time=2.):
    &#34;&#34;&#34;
    ##Description
    Read a reducted file and send data on a ZMQ socket server
    ##Input
    filein = (string) file name
    prefix = (string) prefix to be used to extract origin time from filename
    trange = [tmin, tmax] time range
    drange = [dmin, dmax] distance range
    tdecim = (int) time decimation
    ddecim = (int) space decimation
    verbose = (int) verbosity level
    host = (string) IP address of host
    port = (int) port
    block_time = length of time block sent
    &#34;&#34;&#34;
    import a1das
    import zmq
    import pickle
    from io import BytesIO
    from timeit import default_timer as timer

    f = a1das.open(filein, format=&#39;reducted&#39;)

    #get header usefull values
    dt = f[&#39;dt&#39;]
    nspace = f[&#39;nspace&#39;]
    ntime = f[&#39;ntime&#39;]

    #set distance reading limits
    if drange is not None:
        dlist = f.index(drange=drange)
        space_range = range(dlist[0],dlist[1],ddecim)
    else:
        space_range = range(0,nspace,ddecim)

    # set time reading limits
    if trange is not None:
        tlist = f.index(trange=trange)
        time_range = range(tlist[0], tlist[1],tdecim)
    else:
        time_range=(0,ntime,tdecim)

    dt = dt*tdecim

    #set Febus-file-like parameters
    block_time_size = int(block_time / dt)
    shift_time_size = int(block_time_size/2)
    delta_t = shift_time_size*dt
    f.file_header.block_info={&#39;block_time_size&#39;:block_time_size}

    # set origin time
    #f.set_otime_from_filename(prefix=prefix)
    time = f[&#39;otime&#39;]



    # open ZMQ connection
    context = zmq.Context()
    socket = context.socket(zmq.REP)
    socket.bind(&#34;tcp://%s:%d&#34; % (host, port))
    print(&#39;launching DAS virtual server on address: &lt;&#39;,&#34;tcp://%s:%d&#34; % (host, port),&#39;&gt;&#39;)

    # wait for an acq
    _wait_for_acq(socket, time)

    # Set and Send header(s)
    message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket)

    #
    # Loop reading data
    #
    if f.is_transposed():

        #get HDF5 file descriptor
        fd = f.file_header.fd

        buffer = np.empty((len(space_range),block_time_size),dtype=np.float32)
        # Loop on block time
        for i in range(0,ntime,shift_time_size):
            start = i
            end = i + block_time_size
            for j, jx in enumerate(space_range):
                buffer[j,:] = fd[&#39;/Traces/&#39;+str(jx)][start:end]

            message3 = buffer.transpose().copy()
            socket.send(message3)

            time += delta_t
            _wait_for_acq(socket, time)
            message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket, message2=message2)
    else:
        print(&#39;not yet implemented&#39;)

    f.close()
    socket.close()

def _wait_for_acq(socket, time=0):
    &#34;&#34;&#34;
    Wait for an ACQ message from the server
    &#34;&#34;&#34;
    from datetime import datetime, timezone
    msg = socket.recv()
    acq = struct.unpack(&#34;@d&#34;, msg)[0]
    if acq != 0.:
        raise VirtualServerError(&#39;Wrong Acq&#39;)
    else:
        print(&#39;received &#39;, acq,&#39; @ time&#39;,time,datetime.fromtimestamp(time, tz=timezone.utc).strftime(&#39;%Y:%m:%d-%H:%M:%S.%f&#39;))

def _set_and_send_header_to_ZMQ(dhd, fhd, time, socket, message2=None):
    &#34;&#34;&#34;
    The protocol contains 3 messages, 2 for headers and one for data
    This routine create/update message 1, prepare message 2 and send message1 and message2
    &#34;&#34;&#34;
    import zmq
    from io import BytesIO

    message1 = BytesIO()
    message1.write(np.int32(1))
    message1.write(np.float64(time))

    if message2 is None:
        message2 = BytesIO()
        message2.write(np.float64(dhd[&#39;dx&#39;]))
        message2.write(np.float64(dhd[&#39;dt&#39;]*1000.))
        message2.write(np.float64(dhd[&#39;ospace&#39;]))
        message2.write(np.float64(0.))
        message2.write(np.float64(0.))
        message2.write(np.float64(0.))
        message2.write(np.int32([0]))
        message2.write(np.int32(dhd[&#39;nspace&#39;]-1))
        message2.write(np.int32([0]))
        message2.write(np.int32(fhd.block_info[&#39;block_time_size&#39;]-1))
        message2.write(np.float64(0.)) # to fill 72 bytes
        message2.write(np.int32([0]))

    socket.send(message1.getvalue(),flags=zmq.SNDMORE)
    socket.send(message2.getvalue(),flags=zmq.SNDMORE)

    return message2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="a1das.vserver.ZMQRawVirtualDasServer"><code class="name flex">
<span>def <span class="ident">ZMQRawVirtualDasServer</span></span>(<span>filein, GL, DT, order_time=2, order_space=2, trange=None, drange=None, tdecim=1, ddecim=1, verbose=0, host='127.0.0.1', port=6667)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Convert Febus RAW data HDF5 file to strain[rate] and send them to a ZMQ socket stream</p>
<h2 id="input">input:</h2>
<pre><code>filein: hdf5 (.h5) file to read
GL: Gauge length (in meter)
DT: Derivation time (IN SECOND)
order_time:  finite derivation order in time, no derivation if set to 0 (default 2)
order_space: finite derivation order in space (default 2)
trange:  time range in sec (start,end), (default = None, everything is read)
drange:  distance range in meter (not km) (start,end), (default = None, everything is read)
ddecim:  distance decimation factor (default=1)
tdecim:  time decimation factor (default=1)
verbose: be verbose (default=0, minimum message level)
</code></pre>
<h2 id="usage-example">Usage example</h2>
<pre><code>&gt;&gt;&gt; from a1das import vserver
&gt;&gt;&gt; gauge_length=10.
&gt;&gt;&gt; time_derivation=0.005
&gt;&gt;&gt; vserver.ZMQRawVirtualDasServer('my_RAW_file',gauge_length, time_derivation, host='127.0.0.1',port=6667)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ZMQRawVirtualDasServer(filein,  GL, DT, order_time=2, order_space=2, trange=None, drange=None, tdecim=1, ddecim=1,
                verbose=0, host=&#39;127.0.0.1&#39;, port=6667):
    &#34;&#34;&#34;
    ## Description
    Convert Febus RAW data HDF5 file to strain[rate] and send them to a ZMQ socket stream

    ## input:
        filein: hdf5 (.h5) file to read
        GL: Gauge length (in meter)
        DT: Derivation time (IN SECOND)
        order_time:  finite derivation order in time, no derivation if set to 0 (default 2)
        order_space: finite derivation order in space (default 2)
        trange:  time range in sec (start,end), (default = None, everything is read)
        drange:  distance range in meter (not km) (start,end), (default = None, everything is read)
        ddecim:  distance decimation factor (default=1)
        tdecim:  time decimation factor (default=1)
        verbose: be verbose (default=0, minimum message level)


    ## Usage example
        &gt;&gt;&gt; from a1das import vserver
        &gt;&gt;&gt; gauge_length=10.
        &gt;&gt;&gt; time_derivation=0.005
        &gt;&gt;&gt; vserver.ZMQRawVirtualDasServer(&#39;my_RAW_file&#39;,gauge_length, time_derivation, host=&#39;127.0.0.1&#39;,port=6667)
    &#34;&#34;&#34;

    import h5py
    from .core import open
    from a1das import _raw2strPy
    from ._a1das_exception import WrongValueError
    from timeit import default_timer as timer
    import zmq

    kchunk = 1
    skip = False
    host = &#39;127.0.0.1&#39;
    port = 6667
    use_compression = False
    #
    #  --------------------------- open file for reading
    #
    a1 = open(filein, format=&#39;febus&#39;)

    # open ZMQ connection
    context = zmq.Context()
    socket = context.socket(zmq.REP)
    socket.bind(&#34;tcp://%s:%d&#34; % (host, port))

    #
    #  --------------------------- read header ----------------------
    #
    hd = a1.file_header
    dhd = a1.data_header
    if hd.chan_node == None:
        print(&#39;Cannot read raw file&#39;)
        exit(-1)
    #
    #  --------------------------- block time size

    block_time_size = int(hd.block_info[&#39;block_time_size&#39;] / 2)

    #
    # check whether time decimation factor is ok or not, it must divide
    # the chunk size
    #
    if (block_time_size) % tdecim != 0:
        print(&#39;Error: time decimation factor must be a divider of the chunk size =&#39;, block_time_size)
        print(&#39;try :&#39;)
        for i in range(2, 100):
            if (block_time_size) % i == 0:
                print(&#39;  tdecim=&#39;, i)
        exit(0)

    #
    #   --------------------------- compute time bounds and time vector -----------------
    #

    # indices for chunk (block) of data
    # indices for first and last time record in the first and last block
    # Vector of times in range[from_time, to_time] with tdecim
    # (block, trange, skip, align_on_block, tdecim)
    first_block, last_block, step_block, \
    time_out, block_indices = a1._get_time_bounds(trange=trange, skip=skip)

    #
    #     ---------------------------  compute distance bounds and indices ----------------
    #
    dist_out, dist_ix, dist_in = a1._get_space_bounds(drange, ddecim)
    if drange is not None:
        ospace_drange = drange[0]
    else:
        ospace_drange = 0.

    #
    # --------------------------- size of data to be written ---------------------------
    #
    output_time_size = len(time_out)  # number of time samples with decimation tdecim
    output_space_size = len(dist_out)  # number of space samples with decimation ddecim
    input_space_size = len(dist_in)  # number of space samples without decimation
    # input_time_size = block_time_size

    #
    #   --------------------------- write header dataset structure on output file
    #   Create a single dataset for all records, stored with a chunk size
    #   approximately equal to : kchunk * original_chunk_size
    #
    # Each block contains decim_block_time_size time samples
    # we will write decim_block_time_size * tdecim * kchunk time sample per chunk
    # A chunk is filled when ncblocks are read
    decim_blk_time_size = int(block_time_size / tdecim)
    decim_blk_space_size = output_space_size
    time_chunk_size = (decim_blk_time_size * tdecim * kchunk)
    if time_chunk_size &gt; output_time_size:
        time_chunk_size = output_time_size
        kchunk = int(time_chunk_size / block_time_size) + 1

    ncblock = kchunk * tdecim


    #
    # create messages from header values
    #
    freq_res = a1.file_header.freq_res
    delta_t = 1./freq_res
    time = dhd[&#39;otime&#39;]

    #
    # test GL and DT parameters
    #
    if GL &lt; dhd[&#39;sampling_res&#39;] / 100:
        raise WrongValueError(
            &#39;Gauge length is smaller than sampling resolutionv&#39; + str(GL) + &#39;&lt;&#39; + str(dhd[&#39;sampling_res&#39;]))
    if DT &lt; (1. / dhd[&#39;prf&#39;]):
        raise WrongValueError(&#39;time derivation is smaller than 1/Pulse_Rate_Frequency&#39;)

    #
    # --------------------------- loop reading blocks ----------------------
    #

    buff_out = np.empty((time_chunk_size, output_space_size, 4), np.int8, &#39;C&#39;)
    strain = np.empty((time_chunk_size, output_space_size), np.float64, &#39;C&#39;)
    print(&#39;size of data is &#39;+str(time_chunk_size)+&#39; x &#39;+str(output_space_size) )

    time0 = timer()
    from timeit import default_timer as timer
    last_block_read = list(range(first_block, last_block, step_block))[-1]
    message2 = None
    for i, block in enumerate(range(first_block, last_block, step_block)):

        # set block indices to read
        if block == first_block:
            block_start = block_indices[0][0]
            block_end = block_indices[0][1]
        elif block == last_block_read:
            block_start = block_indices[2][0]
            block_end = block_indices[2][1]
        else:
            block_start = block_indices[1][0]
            block_end = block_indices[1][1]

        # Fill output buffer; when it&#39;s full, write datasets
        jchunk = i % ncblock

        #
        # Read the full bock and compute angle from real and imaginary part
        # phase 1
        phase1_r = hd.chan_node[0][block, block_start:block_end, :]
        phase1_i = hd.chan_node[1][block, block_start:block_end, :]
        # copy decimated spatial data into temporary buffer
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 0] = \
            phase1_r[:, dist_ix.start:dist_ix.stop:dist_ix.step]
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 1] = \
            phase1_i[:, dist_ix.start:dist_ix.stop:dist_ix.step]

        # Phase2, same as above
        phase2_r = hd.chan_node[2][block, block_start:block_end, :]
        phase2_i = hd.chan_node[3][block, block_start:block_end, :]
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 2] = \
            phase2_r[:, dist_ix.start:dist_ix.stop:dist_ix.step]
        buff_out[jchunk * block_time_size:(jchunk + 1) * block_time_size, :, 3] = \
            phase2_i[:, dist_ix.start:dist_ix.stop:dist_ix.step]


        #
        # We have filled the temporary buffer
        # extract time decimated part and convert to strain
        #
        if jchunk == ncblock - 1:

            phase1_r = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 0]).astype(&#39;int32&#39;)
            phase1_i = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 1]).astype(&#39;int32&#39;)
            phase2_r = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 2]).astype(&#39;int32&#39;)
            phase2_i = np.squeeze(buff_out[0:block_time_size * ncblock:tdecim, :, 3]).astype(&#39;int32&#39;)
            strain, GL, DT = _raw2strPy.raw2strpy(strain, phase1_r, phase1_i, phase2_r, phase2_i, dist_out, time_out,
                                                 GL, DT, order_space, order_time, verbose)
            data = strain.astype(&#39;float32&#39;)
            time1 = timer()
            while (time1 - time0 &lt; delta_t):
                time1 = timer()
            time0 = time1

            _wait_for_acq(socket,time)
            message2 = _set_and_send_header_to_ZMQ(dhd, hd, time, socket, message2=message2)
            socket.send(data)
            time += delta_t



    # end of file reached, write partially filled buffer
    if jchunk != ncblock - 1:
        phase1_r = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 0])
        phase1_i = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 1])
        phase2_r = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 2])
        phase2_i = np.squeeze(buff_out[0:(jchunk + 1) * block_time_size:tdecim, :, 3])
        strain, GL, DT = _raw2strPy.raw2strpy(strain, phase1_r, phase1_i, phase2_r, phase2_i, dist_out, time_out,
                                             GL, DT, order_space, order_time, verbose)
        data = strain.astype(&#39;float32&#39;)
        # write to socket
        _wait_for_acq(socket,time)
        message2 = _set_and_send_header_to_ZMQ(dhd, hd, time, socket, message2=message2)
        socket.send(data)

    a1.close()
    socket.close()</code></pre>
</details>
</dd>
<dt id="a1das.vserver.ZMQReductedVirtualServer"><code class="name flex">
<span>def <span class="ident">ZMQReductedVirtualServer</span></span>(<span>filein, prefix, trange=None, drange=None, tdecim=1, ddecim=1, verbose=0, host='127.0.0.1', port=6667, block_time=2.0)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Read a reducted file and send data on a ZMQ socket server</p>
<h2 id="input">Input</h2>
<p>filein = (string) file name
prefix = (string) prefix to be used to extract origin time from filename
trange = [tmin, tmax] time range
drange = [dmin, dmax] distance range
tdecim = (int) time decimation
ddecim = (int) space decimation
verbose = (int) verbosity level
host = (string) IP address of host
port = (int) port
block_time = length of time block sent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ZMQReductedVirtualServer(filein, prefix, trange=None, drange=None, tdecim=1, ddecim=1,
                verbose=0, host=&#39;127.0.0.1&#39;, port=6667, block_time=2.):
    &#34;&#34;&#34;
    ##Description
    Read a reducted file and send data on a ZMQ socket server
    ##Input
    filein = (string) file name
    prefix = (string) prefix to be used to extract origin time from filename
    trange = [tmin, tmax] time range
    drange = [dmin, dmax] distance range
    tdecim = (int) time decimation
    ddecim = (int) space decimation
    verbose = (int) verbosity level
    host = (string) IP address of host
    port = (int) port
    block_time = length of time block sent
    &#34;&#34;&#34;
    import a1das
    import zmq
    import pickle
    from io import BytesIO
    from timeit import default_timer as timer

    f = a1das.open(filein, format=&#39;reducted&#39;)

    #get header usefull values
    dt = f[&#39;dt&#39;]
    nspace = f[&#39;nspace&#39;]
    ntime = f[&#39;ntime&#39;]

    #set distance reading limits
    if drange is not None:
        dlist = f.index(drange=drange)
        space_range = range(dlist[0],dlist[1],ddecim)
    else:
        space_range = range(0,nspace,ddecim)

    # set time reading limits
    if trange is not None:
        tlist = f.index(trange=trange)
        time_range = range(tlist[0], tlist[1],tdecim)
    else:
        time_range=(0,ntime,tdecim)

    dt = dt*tdecim

    #set Febus-file-like parameters
    block_time_size = int(block_time / dt)
    shift_time_size = int(block_time_size/2)
    delta_t = shift_time_size*dt
    f.file_header.block_info={&#39;block_time_size&#39;:block_time_size}

    # set origin time
    #f.set_otime_from_filename(prefix=prefix)
    time = f[&#39;otime&#39;]



    # open ZMQ connection
    context = zmq.Context()
    socket = context.socket(zmq.REP)
    socket.bind(&#34;tcp://%s:%d&#34; % (host, port))
    print(&#39;launching DAS virtual server on address: &lt;&#39;,&#34;tcp://%s:%d&#34; % (host, port),&#39;&gt;&#39;)

    # wait for an acq
    _wait_for_acq(socket, time)

    # Set and Send header(s)
    message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket)

    #
    # Loop reading data
    #
    if f.is_transposed():

        #get HDF5 file descriptor
        fd = f.file_header.fd

        buffer = np.empty((len(space_range),block_time_size),dtype=np.float32)
        # Loop on block time
        for i in range(0,ntime,shift_time_size):
            start = i
            end = i + block_time_size
            for j, jx in enumerate(space_range):
                buffer[j,:] = fd[&#39;/Traces/&#39;+str(jx)][start:end]

            message3 = buffer.transpose().copy()
            socket.send(message3)

            time += delta_t
            _wait_for_acq(socket, time)
            message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket, message2=message2)
    else:
        print(&#39;not yet implemented&#39;)

    f.close()
    socket.close()</code></pre>
</details>
</dd>
<dt id="a1das.vserver.ZMQVirtualDasServer"><code class="name flex">
<span>def <span class="ident">ZMQVirtualDasServer</span></span>(<span>file, host='127.0.0.1', port=6667, block=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Read Febus strain[rate] HDF5 file and send to a ZMQ socket stream</p>
<h2 id="input">Input</h2>
<pre><code>file = hdf5 (.h5) file to read
host = IP adress for the virtual server
port = IP port for the virtual server
</code></pre>
<h2 id="usage-example">Usage example</h2>
<pre><code>&gt;&gt;&gt; from a1das import vserver
&gt;&gt;&gt; vserver.ZMQVirtualDasServer('my_SR_file',host='127.0.0.1',port=6667)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ZMQVirtualDasServer(file, host=&#39;127.0.0.1&#39;, port=6667, block=None):
    &#34;&#34;&#34;
    ## Description
    Read Febus strain[rate] HDF5 file and send to a ZMQ socket stream

    ## Input
        file = hdf5 (.h5) file to read
        host = IP adress for the virtual server
        port = IP port for the virtual server

    ## Usage example
        &gt;&gt;&gt; from a1das import vserver
        &gt;&gt;&gt; vserver.ZMQVirtualDasServer(&#39;my_SR_file&#39;,host=&#39;127.0.0.1&#39;,port=6667)
    &#34;&#34;&#34;
    import a1das
    import zmq
    import pickle
    from io import BytesIO
    from timeit import default_timer as timer

    # open ZMQ connection
    context = zmq.Context()
    socket = context.socket(zmq.REP)
    socket.bind(&#34;tcp://%s:%d&#34; % (host, port))
    print(&#39;launching DAS virtual server on address: &lt;&#39;,&#34;tcp://%s:%d&#34; % (host, port),&#39;&gt;&#39;)

    #
    # open file
    #
    f = a1das.open(file)
    # set origin time
    #f.set_otime_from_filename()
    #read block info
    nblock = f.file_header.block_info[&#39;nb_block&#39;]
    #read freq_res
    freq_res = f.file_header.freq_res
    delta_t = 1./freq_res
    #time = f.data_header[&#39;otime&#39;]
    block_times = f.file_header.block_info[&#39;block_times&#39;]
    time = block_times[0]


    # wait for an acq
    _wait_for_acq(socket, time)

    # Set and Send header(s)
    message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket)

    data = a1das._core_febus_file._read_febus_file_block(f, 0)
    time0 = timer()
    socket.send(data)

    if block is None:
        block = [0, nblock]

    for i in range(block[0], block[-1]):
        #
        # wait for acq
        #
        _wait_for_acq(socket, time)

        #
        # resend headers and data
        #
        time1 = timer()
        #temporisation
        #while (time1 - time0 &lt; delta_t):
        #    time1 = timer()
        time0 = time1
        #time += delta_t
        time = block_times[i]
        message2 = _set_and_send_header_to_ZMQ(f.data_header, f.file_header, time, socket, message2=message2)

        data = a1das._core_febus_file._read_febus_file_block(f, block=i)
        socket.send(data)


    socket.close()
    f.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="a1das" href="index.html">a1das</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="a1das.vserver.ZMQRawVirtualDasServer" href="#a1das.vserver.ZMQRawVirtualDasServer">ZMQRawVirtualDasServer</a></code></li>
<li><code><a title="a1das.vserver.ZMQReductedVirtualServer" href="#a1das.vserver.ZMQReductedVirtualServer">ZMQReductedVirtualServer</a></code></li>
<li><code><a title="a1das.vserver.ZMQVirtualDasServer" href="#a1das.vserver.ZMQVirtualDasServer">ZMQVirtualDasServer</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>